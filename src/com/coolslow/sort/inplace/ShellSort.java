package com.coolslow.sort.inplace;

import com.coolslow.utils.MyUtils;

class ShellSort {


    /**
     * 希尔排序的思想是采用插入排序的方法，
     * 1 先让数组中任意间隔为 h 的元素有序，
     * 2 刚开始 h 的大小可以是 h = n / 2, 接着让 h = n / 4，让 h 一直缩小，
     * 3 当 h = 1 时，也就是此时数组中任意间隔为1的元素有序，此时的数组就是有序的了。
     */

    static <T extends Comparable<T>> void sort(T[] data) {
        if (data == null) {
            return;
        }
        int count = data.length;
        for (int h = count / 2; h > 0; h /= 2) {
            for (int i = h; i < count; i++) {
                T temp = data[i];
                int k = i - h;
                while (k >= 0 && data[k].compareTo(temp) > 0) {
                    k = k - h;
                }
                for (int j = i; j > (k + h); j -= h) {
                    data[j] = data[j - h];
                }
                data[k + h] = temp;
            }

            MyUtils.printProgressing((int) ((Math.log(count) - Math.log(h)) / Math.log(2)), (int) (Math.log(count) / Math.log(2)));
        }

    }


    /*
     *
     * ====================================== 开始创建百万级(1048576个)数据 =======================================
     * ====================================== 创建百万级(1048576个)数据 耗时937毫秒 =======================================
     * ====================================== 开始验证数据 =======================================
     * 1048576个数，没有重复值
     * ====================================== 验证数据 耗时67毫秒 =======================================
     * ====================================== 开始希尔排序 =======================================
     * ====================================== 希尔排序 耗时2844毫秒 =======================================
     * ====================================== 开始排序正确性验证 =======================================
     * 排序正确
     * ====================================== 排序正确性验证 耗时11毫秒 =======================================
     *
     */

}
