# 递归原理

## "递归"是什么？

递归 是指函数直接或间接地调用自己，递归是基于栈来实现的。递归的经典例子就是"斐波拉契（Fibonacci）数列"。
一般地，如果可以用递归来实现的程序，也可以通过循环来实现。用递归来实现的话，代码看起来会相对清晰，但递归的性能
并不占优势，时间敷再多甚至会更大一些。

## LeetCode 涉及递归解决的相关题目

Example: 斐不拉契数列的递归实现
NO-344 反转字符串(递归实现)
NO-24 两两交换链表中的节点
NO-118 Pascal三角(杨辉三角)
NO-119 Pascal三角II(杨辉三角II)
NO-206 反转单链表
NO-70 爬楼梯

## 递推关系

对于一个问题，如果存在递归解决方案，可以按照一下步骤实施。
将问题定义为有待实现的函数F(X)，其中 X 是函数的输入输入，同时也定义了问题的范围。
然后，在函数 F(X)中，我们将会：

1. 将问题分解程较小的范围。x0 ∈ X, x1 ∈ X, x2 ∈ X, ..., xn ∈ X。
2. 调用函数F(x0), F(x1), F(x2), ..., F(xn) 递归地解决 X 的这些子问题。
3. 最后，处理调用递归函数得到的结果来解决对应 X 的问题。 

在实现递归函数时，也有两件重要的事情需要搞清楚：
- 递推关系：一个问题的结果与其子问题的结果之间的关系
- 基本情况：不需要进一步的递归调用就可以直接计算答案的情况，也就是如果我们认为将问题划分为子问题是一种自上而下的方式的最下层。

> 一旦计算出以上两个元素，在想要实现一个递归函数，就只需要根据 "递推关系" 调用函数本身，直到其抵达基本情况即可。

## 递归中的重复计算

通常情况下， 递归是一种只管有效的实现算法算法。但如果不明智地使用，可能带来性能上的损失，例如：重复计算。

通常，需要采用记忆化的方式消除重复计算，最只管的想法就是将已经计算的中间结果加以保存，以便再遇到时重复利用他们而不是消耗资源重新计算。
